# 正则表达式

[【原文地址】](http://www.jb51.net/tools/zhengze.html)，由于文字内容较多，本文为学习摘要总结。

## 目录

* 入门
	* 元字符
	2. 重复
	3. 字符类
	4. 分枝条件
	5. 分组
	6. 反义
* 深入
	* 向后引用
	2. 零宽断言
	3. 负向零宽断言
	4. 注释
	5. 贪婪与懒惰
	6. 处理选项
	7. 平衡组/递归匹配
* 补充

## 入门

### 元字符 

| 语法 | 说明 |
|-----|------|
| `. `  | 匹配除换行符意外的任意字符   |
| `\w`  | 匹配字母、数字、下划线、汉字 |
| `\s`  | 匹配任意的空白符           |
| `\d`  | 匹配数字                  |
| `\b`  | 匹配单词的开始、结束        |
| `^`   | 匹配字符串的开始           |
| `$`   | 匹配字符串的结束           |

**注意：** 如果先查找元字符本身的话，比如查找`.`或者`*`就会出现问题，因为会被解释成别的意思。这时就需要通过`\`进行字符转义。 

### 重复

| 语法 | 说明 |
|-----|------|
| `* `  | 重复零次或更多次    |
| `+ `  | 重复一次或更多次    |
| `? `  | 重复零次或一次      |
| `{n}`     | 重复n次        |
| `{n,}`    | 重复n次或更多次 |
| `{n,m}`   | 重复n到m次     |

### 字符类

在`[]`中定义集合范围，可以轻松指定匹配范围。

**使用场景**：由于元字符匹配的是一个范围内的所有集合，因此在特定场景下无法满足一些需求。比如：匹配元音字母（a,e,i,o,u），元字符就无法完成。 此时，通过字符类即可完成。

**举例：**

* 匹配元音字母：`[aeiou]` 
* 匹配数字集合：`[0-9]`
* 匹配英文、数字、下划线：`[a-z0-9A-Z_]`

### 分枝条件

分枝条件指的是，通过符号`|`对多个指定规则进行判断，满足其中一种规则即可通过。 

**举例：**

* 匹配5位数字的美国邮编、或者连字号间隔的9位数：
	* 正确示例：`\d{5}-\d{4}|\d{5}`
	* 错误示例：`\d{5}|\d{5}-\d{4}`

（上述错误示例，只会匹配5位的邮编（以及9位邮编的前5位）

**注意事项：**使用分枝条件时，将会从左到右判断条件，如果某一个分枝满足条件，则不会再去判断其他条件。

### 分组

当需要匹配重复的内容，并且内容为指定规则的集合时，需要通过小括号指定**子表达式（即分组）**，然后跟上重复次数来匹配。

**举例：** 匹配一个简单地IP地址的表达式：`(\d{1,3}\.){3}\d{1,3}`

**如何理解上述表达式：**`(\d{1,3}\.){3}`将3位数字加上1个英文句号归纳为1个分组，该分组重复3次，最后加上个1~3的数字

### 反义

元字符可以匹配大部分的集合，而如果希望匹配除了这些规则之外的其他集合内容，那么可使用反义：

| 语法 | 说明 |
|-----|------|
| `\W`  | 匹配任意不是字母、数字、下划线、汉字的字符      |
| `\S`  | 匹配任意不是空白符的字符                     |
| `\D`  | 匹配任意非数字的字符                        |
| `\B`  | 匹配任意非单词的开始、结束的位置              |
| `[^x]`       | 匹配除了x以外的任意字符              |
| `[^aeiou]`   | 匹配除了aeiou这几个字母以外的任意字符  |

## 深入理解

### 向后引用

| 分类        | 代码/语法     | 说明 | 
|------------|--------------|-----|
| 捕获        | `(exp)`       | 匹配exp，并捕获文本到自动命名的组里                           |
|            | `(?<name>exp)`| 匹配exp，并捕获文本到名称为`name`的组里，也可以写成(?'name'exp) |
|            | `(?:exp)`     | 匹配exp，不捕获匹配的文本，也不给此分组分配组号                 |
| 零宽断言    | `(?=exp)`      | 匹配exp前面的位置                                          |
|            | `(?<=exp)`    | 匹配exp后面的位置                                          |
|            | `(?!exp)`     | 匹配后面跟的不是exp的位置                                    |
|            | `(?<!exp)`     | 匹前面跟的不是exp的位置                                     |
| 注释        | `(?#comment)`  | 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 |

**举例说明**

匹配重复单词：`\b(\w+)\b\s+\1\b`

**如何理解上述表达式：**首先注意前半部分`\b(\w+)\b`，回顾`b\`表示单词的开头或者结束，因此`(w+)`捕获到了一个单词，这个单词则放入分组1，后续`s+`匹配空格，再然后`\1`表示了之前匹配的那个单词。

这里简单的介绍一下，后续提供实例进行详细说明。

### 零宽断言

正则匹配使用过程中，经常会有一些场景需要指定一个位置（例如`^`、`$`等），除了这些意外，我们可以自定义一些条件去匹配期望的匹配对象。 

* **先行断言** `(?=exp)`，它断言自身出现位置后面能匹配表达式exp
	* 例如：I'm singing while you're dancing希望匹配sing，danc单词，可以通过`\b\w+(?=ing\b)`
* **后发断言** `(?<=exp)`，它断言自身出现位置前面能匹配表达式exp
	* 例如：reading a book希望匹配ading单词，可以通过`(?<=\bre)\w+\b`

### 负向零宽断言

顾名思义，负向就是检测某个字符是否没有出现过。

* **负向先行断言** `(?!exp)`，断言此位置后面不能匹配表达式exp
	* 例如：匹配三位数字，而且这三位数字的后面不能是数字，可以通过`\d{3}(?!\d)`
* **负向后发断言** `(?<!exp)`，断言此位置前面不能匹配表达式exp
	* 例如：匹配单词，前面不是小写字母的七位数字，可以通过`(?<![a-z])\d{7}`

### 注释

编程语言中，均可以通过`//`进行内容注释，正则表达式同样也支持了这个能力，格式为`(?#comment)`

**举例：**

`2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)`

### 贪婪与懒惰

回顾一下前面的**重复**，观察这一个正则`a.*b`，如果用它进行搜索aabab，则最终匹配结果为整个字符串aabab，这种匹配模式成为贪婪匹配。

那么仔细想想，如果我们期望匹配尽可能少的字符，例如期望匹配上述例子中，结果输出为aab，该如何做呢？ 了解之前，我们应该了解这个知识点被称之为**懒惰匹配**

| 语法 | 说明 |
|-----|------|
| `*?`  | 重复零次或更多次，尽可能少重复    |
| `+?`  | 重复一次或更多次，尽可能少重复    |
| `??`  | 重复零次或一次，尽可能少重复      |
| `{n}?`     | 重复n次，尽可能少重复       |
| `{n,}?`    | 重复n次或更多次，尽可能少重复 |
| `{n,m}?`   | 重复n到m次，尽可能少重复     |

### 处理选项

实际开发中，开发的一些函数往往存在一个Option选项，可以进行配置相关内容获取期望的结果。

| 名称 | 说明（参考.Net，当做扩充知识吧） |
|-----|------|
| 忽略大小写 | 匹配时不缺分大小写。 |
| 多行模式  | 更改`^`和`$`含义，使他们分别在任意一行的行首和行尾，而不仅仅在整个字符串的开头和结尾进行匹配。（该模式下，`$`的精确含义是：匹配`\n`之前的位置以及字符串结束的位置） |
| 单行模式 | 更改`.`的含义，使它与每一个字符匹配（包含换行`\n`） |
| 忽略空白 | 忽略表达式中的肺转移空白并且启动由`#`标记的注释 |
| 显示捕获 | 仅仅捕获已被显示命名的组 |

