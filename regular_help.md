# 正则表达式

[【原文地址】](http://www.jb51.net/tools/zhengze.html)，由于文字内容较多，本文为学习摘要总结。

## 目录

* 入门
	* 元字符
	2. 重复
	3. 字符类
	4. 分枝条件
	5. 分组
	6. 反义
* 深入
	* 向后引用
	2. 零宽断言
	3. 负向零宽断言
	4. 注释
	5. 贪婪与懒惰
	6. 处理选项
	7. 平衡组/递归匹配
* 补充

## 正文

### 入门

#### 元字符 

| 语法 | 说明 |
|-----|------|
| `. `  | 匹配除换行符意外的任意字符   |
| `\w`  | 匹配字母、数字、下划线、汉字 |
| `\s`  | 匹配任意的空白符           |
| `\d`  | 匹配数字                  |
| `\b`  | 匹配单词的开始、结束        |
| `^`   | 匹配字符串的开始           |
| `$`   | 匹配字符串的结束           |

**注意：** 如果先查找元字符本身的话，比如查找`.`或者`*`就会出现问题，因为会被解释成别的意思。这时就需要通过`\`进行字符转义。 

#### 重复

| 语法 | 说明 |
|-----|------|
| `* `  | 重复零次或更多次    |
| `+ `  | 重复一次或更多次    |
| `? `  | 重复零次或一次      |
| `{n}`     | 重复n次        |
| `{n,}`    | 重复n次或更多次 |
| `{n,m}`   | 重复n到m次     |

#### 字符类

在`[]`中定义集合范围，可以轻松指定匹配范围。

**使用场景**：由于元字符匹配的是一个范围内的所有集合，因此在特定场景下无法满足一些需求。比如：匹配元音字母（a,e,i,o,u），元字符就无法完成。 此时，通过字符类即可完成。

**举例：**

* 匹配元音字母：`[aeiou]` 
* 匹配数字集合：`[0-9]`
* 匹配英文、数字、下划线：`[a-z0-9A-Z_]`

#### 分枝条件

分枝条件指的是，通过符号`|`对多个指定规则进行判断，满足其中一种规则即可通过。 

**举例：**

* 匹配5位数字的美国邮编、或者连字号间隔的9位数：
	* 正确示例：`\d{5}-\d{4}|\d{5}`
	* 错误示例：`\d{5}|\d{5}-\d{4}`

（上述错误示例，只会匹配5位的邮编（以及9位邮编的前5位）

**注意事项：**使用分枝条件时，将会从左到右判断条件，如果某一个分枝满足条件，则不会再去判断其他条件。

#### 分组

当需要匹配重复的内容，并且内容为指定规则的集合时，需要通过小括号指定**子表达式（即分组）**，然后跟上重复次数来匹配。

**举例：** 匹配一个简单地IP地址的表达式：`(\d{1,3}\.){3}\d{1,3}`

**如何理解上述表达式：**`(\d{1,3}\.){3}`将3位数字加上1个英文句号归纳为1个分组，该分组重复3次，最后加上个1~3的数字

#### 反义

元字符可以匹配大部分的集合，而如果希望匹配除了这些规则之外的其他集合内容，那么可使用反义：

| 语法 | 说明 |
|-----|------|
| `\W`  | 匹配任意不是字母、数字、下划线、汉字的字符      |
| `\S`  | 匹配任意不是空白符的字符                     |
| `\D`  | 匹配任意非数字的字符                        |
| `\B`  | 匹配任意非单词的开始、结束的位置              |
| `[^x]`       | 匹配除了x以外的任意字符              |
| `[^aeiou]`   | 匹配除了aeiou这几个字母以外的任意字符  |

### 深入理解

#### 向后引用

| 分类        | 代码/语法     | 说明 | 
|------------|--------------|-----|
| 捕获        | `(exp)`       | 匹配exp，并捕获文本到自动命名的组里                           |
|            | `(?<name>exp)`| 匹配exp，并捕获文本到名称为`name`的组里，也可以写成(?'name'exp) |
|            | `(?:exp)`     | 匹配exp，不捕获匹配的文本，也不给此分组分配组号                 |
| 零宽断言    | `(?=exp)`      | 匹配exp前面的位置                                          |
|            | `(?<=exp)`    | 匹配exp后面的位置                                          |
|            | `(?!exp)`     | 匹配后面跟的不是exp的位置                                    |
|            | `(?<!exp)`     | 匹前面跟的不是exp的位置                                     |
| 注释        | `(?#comment)`  | 这种类型的分组不对正则表达式的处理产生任何影响，用于提供注释让人阅读 |

**举例说明**

匹配重复单词：`\b(\w+)\b\s+\1\b`

**如何理解上述表达式：**首先注意前半部分`\b(\w+)\b`，回顾`b\`表示单词的开头或者结束，因此`(w+)`捕获到了一个单词，这个单词则放入分组1，后续`s+`匹配空格，再然后`\1`表示了之前匹配的那个单词。

这里简单的介绍一下，后续提供实例进行详细说明。

#### 零宽断言

正则匹配使用过程中，经常会有一些场景需要指定一个位置（例如`^`、`$`等），除了这些意外，我们可以自定义一些条件去匹配期望的匹配对象。 

* `(?=exp)`先行断言，它断言自身出现位置后面能匹配表达式exp
	* 例如：I'm singing while you're dancing希望匹配sing，danc单词，可以通过`\b\w+(?=ing\b)`
* `(?<=exp)`后发断言，它断言自身出现位置前面能匹配表达式exp
	* 例如：reading a book希望匹配ading单词，可以通过`(?<=\bre)\w+\b`

#### 负向零宽断言



